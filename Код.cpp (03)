#include <iostream>
#include "windows.h"
#include <climits>
using namespace std;

const int M = 20, N = 20; // максимальна допустима кількість рядків та стовпців

void get_matr(int in_matr[M][N], int& in_m, int& in_n); // функція для зчитування матриці

void show_matr(const int out_matr[M][N], const int n, const int m); // функція для виведення матриці на екран 

bool isSortedAscending(int* row, int N); // функція перевіряє, чи рядок впорядкований

int min_research(const int out_matr[M][N], const int m, const int n); // функція знаходить мінімальний елемент у матриці

// Matrix44. Дана матриця розміру M × N. Знайти мінімальний серед елементів тих 
// рядків, які впорядковані або по зростанню, або по спадаючій. Якщо впорядковані рядки в матриці 
// відсутні, то вивести 0.
void task_matrix44(); //завдання 1, декларація функції

// Matrix71. Дана матриця розміру M × N. Продублювати стовпець матриці, що містить її мінімальний 
// елемент.
void task_matrix71(); //завдання 2, декларація функції

int main()
{
	SetConsoleOutputCP(1251);
	int menu; // Зміна для номеру завдання
	do
	{ // початок циклу
		cout << "Номер завдання:"; //введення номеру завдання
		cin >> menu; // обирання номеру завдання
		cout << endl; //вільна строка
		switch (menu) {
		case 1: task_matrix44(); break; // 1 - завдання 1
		case 2: task_matrix71(); break; // 2 - завдання 2
		case -1: cout << "Вихід..." << endl; break; // -1 - вихід
		default: cout << "Помилка! Лише 1, 2!" << endl; // інший номер - повторити
		}
		cout << endl; // вільна строка
		cout << "+---------------------+" << endl; // строка задля полегшення візуального сприймання тексту
		cout << endl; // вільна строка
	} // кінець циклу
	while (menu != -1); // умова виконання циклу
	return 0;
}

// функція введення матриці
void get_matr(int in_matr[M][N], int& in_m, int& in_n) {
    do {
        cout << "Введіть кількість рядків (2-20): "; // обмеження на кількість рядків: від 2 до 20
        cin >> in_m;
        cout << "Введіть кількість строк(= рядкам!!!) (2-20): "; // обмеження на кількість стовпців: така сама кількість,
        // як і рядків, від 2 до 20
        cin >> in_n;
    } while (in_n < 2 || in_n > N || in_m < 2 || in_m > M); // перевірка на коректність введених значень
    cout << "Введіть елементи: " << endl; // введення елеменів матриці
    for (int i = 0; i < in_m; i++)
        for (int j = 0; j < in_n; j++)
            cin >> in_matr[i][j]; // вводимо елементи по черзі
}

//функція виведення масиву
void show_matr(const int out_matr[M][N], const int m, const int n) {
    cout << endl << "Матриця: " << endl;
    // перевіряємо кожний рядок по черзі
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            cout << out_matr[i][j] << "\t"; // виведення елементів з табуляцією
        }
        cout << endl; // перехід на новий рядок після виведення всіх елементів поточного рядка
    }
}

// функція перевірки, чи рядок впорядкований
bool isSortedAscending(int row[], int N) {
    for (int i = 1; i < N; i++) {
        if (row[i] < row[i - 1]) { // якщо знайшли зменшення - рядок не впорядкований
            return false; // якщо всі елементи йдкть по зростанню, рядок впорядкований
        }
    }
}

// Завдання 1 реалізація
void task_matrix44()
{
    int matr1[M][N]; // оголошення матриці
    int row, col; // реальні розміри матриці
    get_matr(matr1, row, col); // виклик функції введення
    show_matr(matr1, row, col); // виклик функції виведення

    // Перевіряємо кожний рядок
    for (int i = 0; i < row; i++) {
        // якщо рядок впорядкований по зростанню, виводимо відповідне повідомлення
        if (isSortedAscending(matr1[i], col)) {
            cout << "Рядок " << i + 1 << " впорядкований за зростанням." << endl;
        }
        // якщо рядок не впорядкований, виводимо відповідне повідомлення
        else {
            cout << "Рядок " << i + 1 << " НЕ впорядкований." << endl;
        }
    }
}

// Завдання 2 реалізація
void task_matrix71()
{
    int M, N;

    // Введення даних
    cout << "Введіть кількість рядків (M): "; // вводимо кількість рідків
    cin >> M;
    cout << "Введіть кількість стовпців (N): "; // вводимо кількість стовпців
    cin >> N;

    // Створення динамічної матриці розміру M × N
    int** matrix = new int* [M]; // Створюємо масив вказівників на рядки
    for (int i = 0; i < M; ++i) {
        matrix[i] = new int[N]; // Для кожного рядка виділяємо пам'ять під стовпці
    }
    cout << "Введіть елементи матриці:" << endl;
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            cin >> matrix[i][j]; // Вводимо елементи матриці
        }
    }
    // Знаходження мінімального елемента і його стовпця
    int minVal = INT_MAX; // Ініціалізуємо мінімальний елемент максимально можливим значенням
    int minCol = -1; // Індекс стовпця, в якому знайдено мінімум

    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            if (matrix[i][j] < minVal) { // Якщо поточний елемент менший за мінімальний
                minVal = matrix[i][j]; // Оновлюємо мінімальний елемент
                minCol = j;  // Запам'ятовуємо стовпець з мінімальним елементом
            }
        }
    }
    // Дублювання стовпця, що містить мінімальний елемент
    if (minCol != -1) { // Перевіряємо, чи був знайдений мінімальний елемент
        for (int i = 0; i < M; ++i) { 
            // Переміщаємо всі елементи після мінімального стовпця
            for (int j = N - 1; j > minCol; --j) {
                matrix[i][j] = matrix[i][j - 1]; // Переміщаємо елементи
            }
            // Дублюємо мінімальний стовпець
            matrix[i][minCol + 1] = matrix[i][minCol]; // Вставляємо копію мінімального елемента
        }
    }
    // Виведення результату
    cout << "Матриця після дублювання стовпця з мінімальним елементом:" << endl;
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N + 1; ++j) {  // Кількість стовпців збільшена на 1
            cout << matrix[i][j] << " ";  // Виводимо елементи матриці
        }
        cout << endl;
    }
    // Звільнення динамічної пам'яті
    for (int i = 0; i < M; ++i) { 
        delete[] matrix[i]; // Звільняємо пам'ять для кожного рядка
    }
    delete[] matrix; // Звільняємо пам'ять для масиву вказівників на рядки
}
