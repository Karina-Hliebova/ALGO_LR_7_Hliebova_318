#include <iostream>
#include "windows.h"
#include <vector>
#include <climits>
#include <algorithm>
using namespace std;

// Matrix44. Дана матриця розміру M × N. Знайти мінімальний серед елементів тих 
// рядків, які впорядковані або по зростанню, або по спадаючій. Якщо впорядковані рядки в матриці 
// відсутні, то вивести 0.
void task_matrix44(); //завдання 1, декларація функції

// Matrix71. Дана матриця розміру M × N. Продублювати стовпець матриці, що містить її мінімальний 
// елемент.
void task_matrix71(); //завдання 2, декларація функції

int main()
{
	SetConsoleOutputCP(1251);
	int menu; // зміна для номеру завдання
	do
	{ // початок циклу
		cout << "Номер завдання:"; //введення номеру завдання
		cin >> menu; // обирання номеру завдання
		cout << endl; //вільна строка
		switch (menu) {
		case 1: task_matrix44(); break; // 1 - завдання 1
		case 2: task_matrix71(); break; // 2 - завдання 2
		case -1: cout << "Вихід..." << endl; break; // -1 - вихід
		default: cout << "Помилка! Лише 1, 2!" << endl; // інший номер - повторити
		}
		cout << endl; // вільна строка
		cout << "+---------------------+" << endl; // строка задля полегшення візуального сприймання тексту
		cout << endl; // вільна строка
	} // кінець циклу
	while (menu != -1); // умова виконання циклу
	return 0;
}

// Завдання 1 реалізація
void task_matrix44()
{
	// Функція для перевірки, чи рядок впорядкований по зростанню
	bool isIncreasing(const vector<int>&row) { // Перетворення рядка у вигляд вектора та перерірка, чи всі елементи
		// йдуть в порядку зростання
		for (int i = 1; i < row.size(); i++) { // Перевірка кожного елемента
			if (row[i] < row[i - 1]) { // Якщо елемент менший за попередній, то він не впорядкований по зростанню
				return false;
			}
		}
		return true; // У випадку, якщо всі елементи йдуть по зростанню
	}
	// Функція для перевірки, чи рядок впорядкований по спаданню
	bool isDecreasing(const vector<int>& row) { // Перетворення рядка на вектор, щоб перевірити, чи всі елементи
		// йдуть в порядку спадання
		for (int i = 1; i < row.size(); i++) { // Перевірка кожного елемента по черзі
			if (row[i] > row[i - 1]) { // Якщо елемент більший за попередній, то рядок не вторядкований
				return false; // за спаданням
			}
		}
		return true; // В іншому випадку - впорядкований

	int M, N;
	cin >> M >> N; // Введення кількості рядків (M) та стовпців (N) матриці

	vector<vector<int>> matrix(M, vector<int>(N)); // Створення двовимірного масиву матриці 
	for (int i = 0; i < M; i++) { // Читання елементва матриці 
		for (int j = 0; j < N; j++) {
			cin >> matrix[i][j]; // Зчитування кожного елементу
		}
	}
	int minValue = INT_MAX; // Мінімальне значення серед впорядкованих рядків
	bool found = false;     // Позначення наявності впорядкованих рядків

	// Перевірка кожного рядка
	for (int i = 0; i < M; i++) {  // Перевірка, чи рядок впорядкований або по зростанню, або по спаду
		if (isIncreasing(matrix[i]) || isDecreasing(matrix[i])) {
			found = true; // Помітка, якщо такий рядок знайдено
			int minInRow = *min_element(matrix[i].begin(), matrix[i].end()); // Знаходження мінімального елементу
			// в цьому рядку
			minValue = min(minValue, minInRow); // Оновлення загального мінімуму
		}
	}
	// Виведення результату
	if (found) {
		cout << minValue << endl; // Виведення мінімального значення серед впорядкованих рядків
	}
	else {
		cout << 0 << endl; // Виведення нуля, якщо впорядкованих рядків немає
	}
}


	
