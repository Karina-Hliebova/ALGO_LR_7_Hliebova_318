#include <iostream>
#include "windows.h"
#include <climits>
using namespace std;

// Matrix44. Дана матриця розміру M × N. Знайти мінімальний серед елементів тих 
// рядків, які впорядковані або по зростанню, або по спадаючій. Якщо впорядковані рядки в матриці 
// відсутні, то вивести 0.
void task_matrix44(); //завдання 1, декларація функції

// Matrix71. Дана матриця розміру M × N. Продублювати стовпець матриці, що містить її мінімальний 
// елемент.
void task_matrix71(); //завдання 2, декларація функції

int main()
{
	SetConsoleOutputCP(1251);
	int menu; // Зміна для номеру завдання
	do
	{ // початок циклу
		cout << "Номер завдання:"; //введення номеру завдання
		cin >> menu; // обирання номеру завдання
		cout << endl; //вільна строка
		switch (menu) {
		case 1: task_matrix44(); break; // 1 - завдання 1
		case 2: task_matrix71(); break; // 2 - завдання 2
		case -1: cout << "Вихід..." << endl; break; // -1 - вихід
		default: cout << "Помилка! Лише 1, 2!" << endl; // інший номер - повторити
		}
		cout << endl; // вільна строка
		cout << "+---------------------+" << endl; // строка задля полегшення візуального сприймання тексту
		cout << endl; // вільна строка
	} // кінець циклу
	while (menu != -1); // умова виконання циклу
	return 0;
}

// Завдання 1 реалізація
void task_matrix44()
{
    int M, N;
    cout << "Введіть кількість рядків (M): "; // вводимо кількість рядків
    cin >> M;
    cout << "Введіть кількість стовпців (N): "; // вводимо кількість стовпців
    cin >> N;

    // створюємо динамічну матрицю M × N
    int** matrix = new int* [M]; // Створюємо масив вказівників на рядки матриці
    for (int i = 0; i < M; ++i) {
        matrix[i] = new int[N]; // Для кожного рядка виділяємо пам'ять під стовпці
    }

    cout << "Введіть елементи матриці:" << endl; 
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            cin >> matrix[i][j]; // Вводимо елементи матриці
        }
    }
    // перевірка рядків на впорядкованість
    int minValue = INT_MAX;  // ініціалізуємо мінімальне значення максимально можливим
    bool foundSortedRow = false;  // Ініціалізуємо змінну для індексу стовпця з мінімальним елементом

    // Функція перевірки, чи рядок впорядкований по зростанню
    bool isSortedAscending(int* row, int N) {
        for (int i = 1; i < N; ++i) { 
            if (row[i] < row[i - 1]) { // Якщо поточний елемент менший за попередній, то рядок не впорядкований
                return false;
            }
        }
        return true;  // Якщо всі елементи йдуть по зростанню, рядок впорядкований
    }

    // Функція перевірки, чи рядок впорядкований по спадаючій
    bool isSortedDescending(int* row, int N) {
        for (int i = 1; i < N; ++i) {
            if (row[i] > row[i - 1]) { // Якщо поточний елемент більший за попередній, то рядок не впорядкований
                return false;
            }
        }
        return true; // Якщо всі елементи йдуть по спаду, рядок впорядкований
    }

    for (int i = 0; i < M; ++i) {
        // Перевірка, чи рядок впорядкований
        // Якщо рядок впорядкований (по зростанню або спаду)
        if (isSortedAscending(matrix[i], N) || isSortedDescending(matrix[i], N)) {
            foundSortedRow = true; // Відзначаємо, що знайдено впорядкований рядок
            // Знаходження мінімального серед таких рядків
            int rowMin = matrix[i][0]; // Початкове значення мінімуму - перший елемент рядка
            for (int j = 1; j < N; ++j) { // Перевіряємо всі елементи рядка
                if (matrix[i][j] < rowMin) { // Оновлюємо мінімум, якщо знаходимо менший елемент
                    rowMin = matrix[i][j];
                }
            }
            minValue = min(minValue, rowMin); // Оновлюємо глобальний мінімум серед впорядкованих рядків
        }
    }
        // Виведення результату
        if (foundSortedRow) {
            cout << "Мінімальний елемент серед впорядкованих рядків: " << minValue << endl; // Виводимо мінімальний елемент
        }
        else {
            cout << "Впорядкованих рядків не знайдено." << endl; // Якщо впорядковані рядки не знайдено
        }

        // Звільнення динамічної пам'яті
        for (int i = 0; i < M; ++i) {
            delete[] matrix[i]; // Звільняємо пам'ять для кожного рядка
        }
        delete[] matrix; // Звільняємо пам'ять для масиву вказівників на рядки
}

// Завдання 2 реалізація
void task_matrix71()
{
    int M, N;

    // Введення даних
    cout << "Введіть кількість рядків (M): "; // вводимо кількість рідків
    cin >> M;
    cout << "Введіть кількість стовпців (N): "; // вводимо кількість стовпців
    cin >> N;

    // Створення динамічної матриці розміру M × N
    int** matrix = new int* [M]; // Створюємо масив вказівників на рядки
    for (int i = 0; i < M; ++i) {
        matrix[i] = new int[N]; // Для кожного рядка виділяємо пам'ять під стовпці
    }
    cout << "Введіть елементи матриці:" << endl;
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            cin >> matrix[i][j]; // Вводимо елементи матриці
        }
    }
    // Знаходження мінімального елемента і його стовпця
    int minVal = INT_MAX; // Ініціалізуємо мінімальний елемент максимально можливим значенням
    int minCol = -1; // Індекс стовпця, в якому знайдено мінімум

    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            if (matrix[i][j] < minVal) { // Якщо поточний елемент менший за мінімальний
                minVal = matrix[i][j]; // Оновлюємо мінімальний елемент
                minCol = j;  // Запам'ятовуємо стовпець з мінімальним елементом
            }
        }
    }
    // Дублювання стовпця, що містить мінімальний елемент
    if (minCol != -1) { // Перевіряємо, чи був знайдений мінімальний елемент
        for (int i = 0; i < M; ++i) { 
            // Переміщаємо всі елементи після мінімального стовпця
            for (int j = N - 1; j > minCol; --j) {
                matrix[i][j] = matrix[i][j - 1]; // Переміщаємо елементи
            }
            // Дублюємо мінімальний стовпець
            matrix[i][minCol + 1] = matrix[i][minCol]; // Вставляємо копію мінімального елемента
        }
    }
    // Виведення результату
    cout << "Матриця після дублювання стовпця з мінімальним елементом:" << endl;
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N + 1; ++j) {  // Кількість стовпців збільшена на 1
            cout << matrix[i][j] << " ";  // Виводимо елементи матриці
        }
        cout << endl;
    }
    // Звільнення динамічної пам'яті
    for (int i = 0; i < M; ++i) { 
        delete[] matrix[i]; // Звільняємо пам'ять для кожного рядка
    }
    delete[] matrix; // Звільняємо пам'ять для масиву вказівників на рядки
}
